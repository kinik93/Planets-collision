<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>ThreeJs and shader demo</title>
	<style>
		body { margin: 0; padding: 0; font-size: 0; }
		canvas { width: 100%; height: 100%; }
	</style>
	<script src="js/three.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="utils.js"></script>
	<script src="js/constantsUtill.js"></script>
</head>

<body>

<script id="sunVertexShader" type="x-shader/x-vertex">
	varying vec2 vTextCoord;

	uniform float time;

	void main() {

		gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, position.z, 1.0);
		vTextCoord = vec2(position);
	}
</script>

<script id="sunFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D mytexture;
    varying vec2 vTextCoord;

	void main() {
	    gl_FragColor = texture2D(mytexture, vTextCoord);

	}
</script>

<script id="planetVertexShader" type="x-shader/x-vertex">
	varying vec2 vTextCoord;

	varying vec4 vPosition; //for light purpose

	void main() {

	    vPosition = vec4(position, 1.0);

		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		vTextCoord = vec2(position);
	}
</script>

<script id="planetFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D mytexture;
    varying vec2 vTextCoord;

    varying vec4 vPosition;

    uniform vec3 center;
    uniform vec3 uLight;

	void main() {
	    vec3 toLight = normalize(uLight-vec3(vPosition));
        vec3 normal = normalize(vec3(vPosition)-vec3(center));
        float diffuse = max(0.0, dot(normal, toLight)); //angle beetween normal and toLight
        vec4 colorTmp = texture2D(mytexture, vTextCoord);
        vec3 color = diffuse*vec3(colorTmp);
	    gl_FragColor = vec4(color, 1.0);
	}
</script>

<script id="vertexShaderPlanetImpact" type="x-shader/x-vertex">
	varying vec2 vTextCoord;
	uniform float time;
	uniform vec3 hitPoint;
	uniform vec3 vcm;
	uniform float deltaEk;
	uniform vec3 center;
	uniform float radius;
	uniform vec3 sunCenter;

	//varying float tmp; //uncomment to view particles involved

	highp float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

	void main() {


	    float dist1 = distance(position, hitPoint);
	    float dist2 = distance(position, center);

		vec3 sunDirection = sunCenter - position;
	    vec3 impactDirection = position - hitPoint;

	    vec3 positionToSun = vec3(position);

	    float f = 0.8*exp(-0.8*dist1)*sqrt(2.0*deltaEk);
	    //float f = log(deltaEk)/(10.0*dist1);

        vec3 vNorm = normalize(vcm);

        float randomFactor = rand(vec2(rand(vec2(position.x, position.y)), position.z));
        if((dist1 < radius*2.0*0.85) && (dist2 > radius*0.5)){
            //tmp = 1.0;
            f = (f + randomFactor)/100.0;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + impactDirection.x*f*time, position.y + impactDirection.y*f*time, position.z + impactDirection.z*f*time, 1.0);


        }
        else{

            /*positionToSun = vec3(position.x + sunDirection.x * randomFactor/100.0 * time,
             					 position.y + sunDirection.y * randomFactor/100.0 * time,
             					 position.z + sunDirection.z * randomFactor/100.0 * time);
             					 */

            /*positionToSun = vec3(position.x / log(time/100.0+2.0),
             					 position.y / log(time/100.0+2.0),
             					 position.z / log(time/100.0+2.0));*/
            positionToSun = position;
            float log_scale = 0.01;
            if(time < 10.0){
                log_scale = 0.1;

            }
            float underTheSurface = 0.98;
            vec3 final = vec3(position-sunCenter);
            final = normalize(final);
            final = vec3(final.x*10.0*underTheSurface, final.y*10.0*underTheSurface, final.z*10.0*underTheSurface);
            final = final+sunCenter;
            float lambda = 1.0-0.005*time;
            positionToSun = vec3((1.0-lambda)*final.x + lambda*position.x, (1.0-lambda)*final.y + lambda*position.y, (1.0-lambda)*final.z + lambda*position.z);
            if (distance(final, sunCenter)>distance(positionToSun, sunCenter) || (dot(positionToSun, vec3(final-sunCenter)) < 0.0)){
                positionToSun = final;
            }
         	gl_Position = projectionMatrix * modelViewMatrix * vec4(positionToSun, 1.0);
        }
		vTextCoord = vec2(position);
	}
</script>

<script id="fragmentShaderPlanetImpact" type="x-shader/x-fragment">
    uniform sampler2D mytexture;
    varying vec2 vTextCoord;

    varying float tmp;
	void main() {
	    gl_FragColor = texture2D(mytexture, vTextCoord);
	    /*
	    if(tmp == 1.0){
	        gl_FragColor = texture2D(mytexture, vTextCoord);
	    }
	    else{
	        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	    }
	    */
	}
</script>

<script>

    //RENDERER
    var renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    //SCENE AND CAMERA
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight);
    camera.position.z = 200;
    scene.add(camera);

    //SET CUBE BACKGROUND
    var genCubeUrls = function( prefix, postfix ) {
        return [
            prefix + 'px' + postfix, prefix + 'nx' + postfix,
            prefix + 'py' + postfix, prefix + 'ny' + postfix,
            prefix + 'pz' + postfix, prefix + 'nz' + postfix
        ];
    };

    var ldrUrls = genCubeUrls( "images/MilkyWay/dark-s_", ".jpg" );
    scene.background = new THREE.CubeTextureLoader().load(ldrUrls);

    //AXES HELPER
    var axesHelper = new THREE.AxesHelper(5); //The X axis is red. The Y axis is green. The Z axis is blue.
    scene.add(axesHelper);

    //CAMERA CONTROLS
    var controls;
    controls = new THREE.OrbitControls( camera, renderer.domElement );

    //LIGHT
    var light = new THREE.PointLight( 0xff0000, 1, 100 );
    light.position.set( 0, 0, 0 );
    scene.add( light );


    //****************************
    //Sun modeling

    const SUN_MATERIAL = create_shader_material('images/sun.png', 'sunVertexShader', 'sunFragmentShader');
    var sun ={
        radius: SUN_RADIUS,
        mass: SUN_MASS,
        obj: createPointsPlanet(SUN_RADIUS, SUN_PARTICLES, SUN_INIT_POSITION, SUN_MATERIAL),
        center: SUN_INIT_POSITION,
        velocity: SUN_INIT_VELOCITY,
        acceleration: SUN_INIT_ACCELERATION
    };
    scene.add(sun.obj);
    sun.obj.material.uniforms.time = {value: 0};


    //****************************
    //Asteroid modeling

    const ASTEROID_MATERIAL = create_shader_material('images/asteroid.jpg', 'planetVertexShader', 'planetFragmentShader');
    var asteroid ={
        radius: ASTEROID_RADIUS,
        mass: ASTEROID_MASS,
        obj: createPointsPlanet(ASTEROID_RADIUS, ASTEROID_PARTICLES, ASTEROID_INIT_POSITION, ASTEROID_MATERIAL),
        center: ASTEROID_INIT_POSITION,
        velocity: ASTEROID_INIT_VELOCITY,
        acceleration: ASTEROID_INIT_ACCELERATION
    };
    asteroid.obj.material.uniforms.center = {value: asteroid.center};
    asteroid.obj.material.uniforms.uLight = {value: sun.center};
    scene.add(asteroid.obj);

    //****************************
	//Earth modeling

    var loader = new THREE.TextureLoader();
    var earthTexture = loader.load( 'images/land_ocean_ice_cloud_2048.jpg');

	var earthGeometry = new THREE.SphereBufferGeometry( 3, 20, 20 );
	var earthMaterial = new THREE.MeshBasicMaterial( { map: earthTexture, overdraw: 0.5} );
	var earth = new THREE.Mesh( earthGeometry, earthMaterial );
	scene.add(earth);
	earth.position.set(EARTH_INIT_POSITION.x, EARTH_INIT_POSITION.y, EARTH_INIT_POSITION.z);


    //****************************
    //Jupiter modeling

    var loader = new THREE.TextureLoader();
    var jupTexture = loader.load( 'images/jupiter.jpg');

    var jupGeometry = new THREE.SphereBufferGeometry( 3, 20, 20 );
    var jupMaterial = new THREE.MeshBasicMaterial( { map: jupTexture, overdraw: 0.5} );
    var jupiter = new THREE.Mesh( jupGeometry, jupMaterial );
    scene.add(jupiter);
    jupiter.position.set(JUPITER_INIT_POSITION.x, JUPITER_INIT_POSITION.y, JUPITER_INIT_POSITION.z);

	//*****************************
    //Audio

    //Create an AudioListener and add it to the camera
    var listener = new THREE.AudioListener();
    camera.add( listener );
    // create a global audio source
    var sound = new THREE.Audio( listener );
    var audioLoader = new THREE.AudioLoader();
    audioLoader.load( 'audio/interstellarPiano.mp3', function( buffer ) {
        sound.setBuffer( buffer );
        sound.setLoop(true);
        sound.setVolume(0.5);
        //sound.play();
    });

	//**********************************

    var impact = false;
    var asteroidHit;

    function animate() {


        if(asteroid.center.distanceTo(sun.center) < (asteroid.radius + sun.radius)-2 && impact == false){
            console.log(asteroid.velocity)
            impact = true;

            var vcm, dEk;
            [vcm, dEk] = anelastic_impact(asteroid, sun);
            console.log("params");
            console.log(vcm, dEk);
            vcm = vectorScalarProduct(vcm, Math.pow(10, 3));
            dEk = dEk * Math.pow(10, -40);



            var hitPoint = vectorScalarProduct(vectorSum(asteroid.center, sun.center), 0.5);
            scene.remove(asteroid.obj);

            //Vector view of center of mass velocity vector
            var arrowHelper = new THREE.ArrowHelper( vcm.normalize(), hitPoint, 10, 0xffff00 );
            scene.add( arrowHelper );

            const ASTEROID_IMPACT_MATERIAL = create_shader_material('images/asteroid.jpg', 'vertexShaderPlanetImpact', 'fragmentShaderPlanetImpact');
            asteroidHit ={
                radius: ASTEROID_RADIUS,
                mass: ASTEROID_MASS,
                obj: createPointsPlanet(ASTEROID_RADIUS, ASTEROID_PARTICLES, asteroid.center, ASTEROID_IMPACT_MATERIAL),
                center: asteroid.center,
                velocity: asteroid.velocity,
                acceleration: asteroid.acceleration
            };
            scene.add(asteroidHit.obj);

            asteroidHit.obj.material.uniforms.time = {value: 0};
            asteroidHit.obj.material.uniforms.hitPoint = {value: hitPoint};
            asteroidHit.obj.material.uniforms.deltaEk = {value: dEk};
            asteroidHit.obj.material.uniforms.vcm = {value: vcm};
            asteroidHit.obj.material.uniforms.center = {value: asteroidHit.center};
            asteroidHit.obj.material.uniforms.radius = {value: asteroidHit.radius};
            asteroidHit.obj.material.uniforms.sunCenter = {value: sun.center};
        }

        else if(impact == true){
            asteroidHit.obj.material.uniforms.time.value += 0.1;//TODO: 1/60;
        }

        else {
            var asteroidInitPosition = asteroid.obj.geometry.attributes.position.array.slice(0); //copy asteroid init position
            newton_movement(asteroid, sun, asteroidInitPosition);

            asteroid.obj.material.uniforms.center = {value: asteroid.center}; //update asteroid center uniform variable (light purposes)
        }

        var time = performance.now()/1000; //time second

        //sun texture animation
        sun.obj.material.uniforms.time.value += (time/10);
        shake(sun);

        //Earth orbit
        EARTH_VELOCITY = planet_newton_movement(earth, EARTH_VELOCITY, sun);
        earth.rotation.y = 5*time;

        //Jupiter orbit
        JUPITER_VELOCITY = planet_newton_movement(jupiter, JUPITER_VELOCITY, sun);
        jupiter.rotation.y = 5*time;

        requestAnimationFrame(animate);
        camera.updateMatrixWorld( true );
        renderer.render(scene, camera);

    }
    animate();
	</script>

</body>
</html>